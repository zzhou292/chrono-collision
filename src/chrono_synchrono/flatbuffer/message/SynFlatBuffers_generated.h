// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_

#include "chrono_thirdparty/flatbuffers/include/flatbuffers/flatbuffers.h"

namespace SynFlatBuffers {
namespace SPAT {

struct State;

struct Lane;

}  // namespace SPAT

struct Vector;

struct Quaternion;

struct Pose;

namespace Approach {

struct State;

struct Lane;

}  // namespace Approach

namespace MAP {

struct State;

struct intersection;

}  // namespace MAP

namespace Agent {
namespace WheeledVehicle {

struct State;

struct Description;

}  // namespace WheeledVehicle

namespace TrackedVehicle {

struct State;

struct Description;

}  // namespace TrackedVehicle

namespace Environment {

struct State;

struct Description;

}  // namespace Environment

struct State;

struct Description;

}  // namespace Agent

namespace Terrain {
namespace SCM {

struct NodeLevel;

struct State;

}  // namespace SCM

struct State;

}  // namespace Terrain

namespace Sensor {
namespace Camera {

struct RGBA8;

struct R8;

}  // namespace Camera

namespace Lidar {

struct XYZI;

struct DI;

}  // namespace Lidar

namespace IMU {

struct Vec;

struct IMUData;

}  // namespace IMU

namespace GPS {

struct GPSData;

}  // namespace GPS

struct SensorBuffer;

struct State;

}  // namespace Sensor

struct Buffer;

struct Message;

namespace SPAT {

enum Color {
  Color_Green = 0,
  Color_Yellow = 1,
  Color_Red = 2,
  Color_MIN = Color_Green,
  Color_MAX = Color_Red
};

inline const Color (&EnumValuesColor())[3] {
  static const Color values[] = {
    Color_Green,
    Color_Yellow,
    Color_Red
  };
  return values;
}

inline const char * const *EnumNamesColor() {
  static const char * const names[4] = {
    "Green",
    "Yellow",
    "Red",
    nullptr
  };
  return names;
}

inline const char *EnumNameColor(Color e) {
  if (e < Color_Green || e > Color_Red) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColor()[index];
}

}  // namespace SPAT

namespace Agent {

enum Type {
  Type_NONE = 0,
  Type_WheeledVehicle_State = 1,
  Type_WheeledVehicle_Description = 2,
  Type_TrackedVehicle_State = 3,
  Type_TrackedVehicle_Description = 4,
  Type_Environment_State = 5,
  Type_Environment_Description = 6,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Environment_Description
};

inline const Type (&EnumValuesType())[7] {
  static const Type values[] = {
    Type_NONE,
    Type_WheeledVehicle_State,
    Type_WheeledVehicle_Description,
    Type_TrackedVehicle_State,
    Type_TrackedVehicle_Description,
    Type_Environment_State,
    Type_Environment_Description
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[8] = {
    "NONE",
    "WheeledVehicle_State",
    "WheeledVehicle_Description",
    "TrackedVehicle_State",
    "TrackedVehicle_Description",
    "Environment_State",
    "Environment_Description",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_Environment_Description) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::WheeledVehicle::State> {
  static const Type enum_value = Type_WheeledVehicle_State;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::WheeledVehicle::Description> {
  static const Type enum_value = Type_WheeledVehicle_Description;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::TrackedVehicle::State> {
  static const Type enum_value = Type_TrackedVehicle_State;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::TrackedVehicle::Description> {
  static const Type enum_value = Type_TrackedVehicle_Description;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::Environment::State> {
  static const Type enum_value = Type_Environment_State;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::Environment::Description> {
  static const Type enum_value = Type_Environment_Description;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace Agent

namespace Terrain {

enum Type {
  Type_NONE = 0,
  Type_SCM_State = 1,
  Type_MIN = Type_NONE,
  Type_MAX = Type_SCM_State
};

inline const Type (&EnumValuesType())[2] {
  static const Type values[] = {
    Type_NONE,
    Type_SCM_State
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[3] = {
    "NONE",
    "SCM_State",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_SCM_State) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Terrain::SCM::State> {
  static const Type enum_value = Type_SCM_State;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

}  // namespace Terrain

namespace Sensor {

enum Type {
  Type_Camera_RGBA8 = 0,
  Type_Camera_R8 = 1,
  Type_Lidar_DI = 2,
  Type_Lidar_XYZI = 3,
  Type_IMU_IMUData = 4,
  Type_GPS_GPSData = 5,
  Type_MIN = Type_Camera_RGBA8,
  Type_MAX = Type_GPS_GPSData
};

inline const Type (&EnumValuesType())[6] {
  static const Type values[] = {
    Type_Camera_RGBA8,
    Type_Camera_R8,
    Type_Lidar_DI,
    Type_Lidar_XYZI,
    Type_IMU_IMUData,
    Type_GPS_GPSData
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[7] = {
    "Camera_RGBA8",
    "Camera_R8",
    "Lidar_DI",
    "Lidar_XYZI",
    "IMU_IMUData",
    "GPS_GPSData",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_Camera_RGBA8 || e > Type_GPS_GPSData) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

}  // namespace Sensor

enum Type {
  Type_NONE = 0,
  Type_Agent_State = 1,
  Type_Agent_Description = 2,
  Type_SPAT_State = 3,
  Type_MAP_State = 4,
  Type_Terrain_State = 5,
  Type_Sensor_State = 6,
  Type_Approach_State = 7,
  Type_MIN = Type_NONE,
  Type_MAX = Type_Approach_State
};

inline const Type (&EnumValuesType())[8] {
  static const Type values[] = {
    Type_NONE,
    Type_Agent_State,
    Type_Agent_Description,
    Type_SPAT_State,
    Type_MAP_State,
    Type_Terrain_State,
    Type_Sensor_State,
    Type_Approach_State
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[9] = {
    "NONE",
    "Agent_State",
    "Agent_Description",
    "SPAT_State",
    "MAP_State",
    "Terrain_State",
    "Sensor_State",
    "Approach_State",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_NONE || e > Type_Approach_State) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

template<typename T> struct TypeTraits {
  static const Type enum_value = Type_NONE;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::State> {
  static const Type enum_value = Type_Agent_State;
};

template<> struct TypeTraits<SynFlatBuffers::Agent::Description> {
  static const Type enum_value = Type_Agent_Description;
};

template<> struct TypeTraits<SynFlatBuffers::SPAT::State> {
  static const Type enum_value = Type_SPAT_State;
};

template<> struct TypeTraits<SynFlatBuffers::MAP::State> {
  static const Type enum_value = Type_MAP_State;
};

template<> struct TypeTraits<SynFlatBuffers::Terrain::State> {
  static const Type enum_value = Type_Terrain_State;
};

template<> struct TypeTraits<SynFlatBuffers::Sensor::State> {
  static const Type enum_value = Type_Sensor_State;
};

template<> struct TypeTraits<SynFlatBuffers::Approach::State> {
  static const Type enum_value = Type_Approach_State;
};

bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type);
bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

namespace Terrain {
namespace SCM {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) NodeLevel FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  double level_;

 public:
  NodeLevel() {
    memset(static_cast<void *>(this), 0, sizeof(NodeLevel));
  }
  NodeLevel(int32_t _x, int32_t _y, double _level)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        level_(flatbuffers::EndianScalar(_level)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double level() const {
    return flatbuffers::EndianScalar(level_);
  }
};
FLATBUFFERS_STRUCT_END(NodeLevel, 16);

}  // namespace SCM
}  // namespace Terrain

namespace Sensor {
namespace Camera {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) RGBA8 FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t R_;
  int8_t G_;
  int8_t B_;
  int8_t A_;

 public:
  RGBA8() {
    memset(static_cast<void *>(this), 0, sizeof(RGBA8));
  }
  RGBA8(int8_t _R, int8_t _G, int8_t _B, int8_t _A)
      : R_(flatbuffers::EndianScalar(_R)),
        G_(flatbuffers::EndianScalar(_G)),
        B_(flatbuffers::EndianScalar(_B)),
        A_(flatbuffers::EndianScalar(_A)) {
  }
  int8_t R() const {
    return flatbuffers::EndianScalar(R_);
  }
  int8_t G() const {
    return flatbuffers::EndianScalar(G_);
  }
  int8_t B() const {
    return flatbuffers::EndianScalar(B_);
  }
  int8_t A() const {
    return flatbuffers::EndianScalar(A_);
  }
};
FLATBUFFERS_STRUCT_END(RGBA8, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) R8 FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t R_;

 public:
  R8() {
    memset(static_cast<void *>(this), 0, sizeof(R8));
  }
  R8(int8_t _R)
      : R_(flatbuffers::EndianScalar(_R)) {
  }
  int8_t R() const {
    return flatbuffers::EndianScalar(R_);
  }
};
FLATBUFFERS_STRUCT_END(R8, 1);

}  // namespace Camera

namespace Lidar {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) XYZI FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float intensity_;

 public:
  XYZI() {
    memset(static_cast<void *>(this), 0, sizeof(XYZI));
  }
  XYZI(float _x, float _y, float _z, float _intensity)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        intensity_(flatbuffers::EndianScalar(_intensity)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float intensity() const {
    return flatbuffers::EndianScalar(intensity_);
  }
};
FLATBUFFERS_STRUCT_END(XYZI, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) DI FLATBUFFERS_FINAL_CLASS {
 private:
  float range_;
  float intensity_;

 public:
  DI() {
    memset(static_cast<void *>(this), 0, sizeof(DI));
  }
  DI(float _range, float _intensity)
      : range_(flatbuffers::EndianScalar(_range)),
        intensity_(flatbuffers::EndianScalar(_intensity)) {
  }
  float range() const {
    return flatbuffers::EndianScalar(range_);
  }
  float intensity() const {
    return flatbuffers::EndianScalar(intensity_);
  }
};
FLATBUFFERS_STRUCT_END(DI, 8);

}  // namespace Lidar

namespace IMU {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Vec FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  Vec() {
    memset(static_cast<void *>(this), 0, sizeof(Vec));
  }
  Vec(double _x, double _y, double _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) IMUData FLATBUFFERS_FINAL_CLASS {
 private:
  SynFlatBuffers::Sensor::IMU::Vec Accel_;
  double Roll_;
  double Pitch_;
  double Yaw_;

 public:
  IMUData() {
    memset(static_cast<void *>(this), 0, sizeof(IMUData));
  }
  IMUData(const SynFlatBuffers::Sensor::IMU::Vec &_Accel, double _Roll, double _Pitch, double _Yaw)
      : Accel_(_Accel),
        Roll_(flatbuffers::EndianScalar(_Roll)),
        Pitch_(flatbuffers::EndianScalar(_Pitch)),
        Yaw_(flatbuffers::EndianScalar(_Yaw)) {
  }
  const SynFlatBuffers::Sensor::IMU::Vec &Accel() const {
    return Accel_;
  }
  double Roll() const {
    return flatbuffers::EndianScalar(Roll_);
  }
  double Pitch() const {
    return flatbuffers::EndianScalar(Pitch_);
  }
  double Yaw() const {
    return flatbuffers::EndianScalar(Yaw_);
  }
};
FLATBUFFERS_STRUCT_END(IMUData, 48);

}  // namespace IMU

namespace GPS {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) GPSData FLATBUFFERS_FINAL_CLASS {
 private:
  double Latitude_;
  double Longitude_;
  double Altitude_;
  double Time_;

 public:
  GPSData() {
    memset(static_cast<void *>(this), 0, sizeof(GPSData));
  }
  GPSData(double _Latitude, double _Longitude, double _Altitude, double _Time)
      : Latitude_(flatbuffers::EndianScalar(_Latitude)),
        Longitude_(flatbuffers::EndianScalar(_Longitude)),
        Altitude_(flatbuffers::EndianScalar(_Altitude)),
        Time_(flatbuffers::EndianScalar(_Time)) {
  }
  double Latitude() const {
    return flatbuffers::EndianScalar(Latitude_);
  }
  double Longitude() const {
    return flatbuffers::EndianScalar(Longitude_);
  }
  double Altitude() const {
    return flatbuffers::EndianScalar(Altitude_);
  }
  double Time() const {
    return flatbuffers::EndianScalar(Time_);
  }
};
FLATBUFFERS_STRUCT_END(GPSData, 32);

}  // namespace GPS
}  // namespace Sensor

namespace SPAT {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_LANES = 6
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *lanes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *>(VT_LANES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_LANES) &&
           verifier.VerifyVector(lanes()) &&
           verifier.VerifyVectorOfTables(lanes()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_lanes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>> lanes) {
    fbb_.AddOffset(State::VT_LANES, lanes);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>> lanes = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_lanes(lanes);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>> *lanes = nullptr) {
  auto lanes__ = lanes ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::SPAT::Lane>>(*lanes) : 0;
  return SynFlatBuffers::SPAT::CreateState(
      _fbb,
      time,
      lanes__);
}

struct Lane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTERSECTION = 4,
    VT_APPROACH = 6,
    VT_LANE = 8,
    VT_COLOR = 10
  };
  int32_t intersection() const {
    return GetField<int32_t>(VT_INTERSECTION, 0);
  }
  int32_t approach() const {
    return GetField<int32_t>(VT_APPROACH, 0);
  }
  int32_t lane() const {
    return GetField<int32_t>(VT_LANE, 0);
  }
  SynFlatBuffers::SPAT::Color color() const {
    return static_cast<SynFlatBuffers::SPAT::Color>(GetField<int8_t>(VT_COLOR, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INTERSECTION) &&
           VerifyField<int32_t>(verifier, VT_APPROACH) &&
           VerifyField<int32_t>(verifier, VT_LANE) &&
           VerifyField<int8_t>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
};

struct LaneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_intersection(int32_t intersection) {
    fbb_.AddElement<int32_t>(Lane::VT_INTERSECTION, intersection, 0);
  }
  void add_approach(int32_t approach) {
    fbb_.AddElement<int32_t>(Lane::VT_APPROACH, approach, 0);
  }
  void add_lane(int32_t lane) {
    fbb_.AddElement<int32_t>(Lane::VT_LANE, lane, 0);
  }
  void add_color(SynFlatBuffers::SPAT::Color color) {
    fbb_.AddElement<int8_t>(Lane::VT_COLOR, static_cast<int8_t>(color), 0);
  }
  explicit LaneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaneBuilder &operator=(const LaneBuilder &);
  flatbuffers::Offset<Lane> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lane>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lane> CreateLane(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t intersection = 0,
    int32_t approach = 0,
    int32_t lane = 0,
    SynFlatBuffers::SPAT::Color color = SynFlatBuffers::SPAT::Color_Green) {
  LaneBuilder builder_(_fbb);
  builder_.add_lane(lane);
  builder_.add_approach(approach);
  builder_.add_intersection(intersection);
  builder_.add_color(color);
  return builder_.Finish();
}

}  // namespace SPAT

struct Vector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_X) &&
           VerifyField<double>(verifier, VT_Y) &&
           VerifyField<double>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct VectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(double x) {
    fbb_.AddElement<double>(Vector::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(Vector::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(Vector::VT_Z, z, 0.0);
  }
  explicit VectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorBuilder &operator=(const VectorBuilder &);
  flatbuffers::Offset<Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector> CreateVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0) {
  VectorBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Quaternion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_E0 = 4,
    VT_E1 = 6,
    VT_E2 = 8,
    VT_E3 = 10
  };
  double e0() const {
    return GetField<double>(VT_E0, 0.0);
  }
  double e1() const {
    return GetField<double>(VT_E1, 0.0);
  }
  double e2() const {
    return GetField<double>(VT_E2, 0.0);
  }
  double e3() const {
    return GetField<double>(VT_E3, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_E0) &&
           VerifyField<double>(verifier, VT_E1) &&
           VerifyField<double>(verifier, VT_E2) &&
           VerifyField<double>(verifier, VT_E3) &&
           verifier.EndTable();
  }
};

struct QuaternionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_e0(double e0) {
    fbb_.AddElement<double>(Quaternion::VT_E0, e0, 0.0);
  }
  void add_e1(double e1) {
    fbb_.AddElement<double>(Quaternion::VT_E1, e1, 0.0);
  }
  void add_e2(double e2) {
    fbb_.AddElement<double>(Quaternion::VT_E2, e2, 0.0);
  }
  void add_e3(double e3) {
    fbb_.AddElement<double>(Quaternion::VT_E3, e3, 0.0);
  }
  explicit QuaternionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuaternionBuilder &operator=(const QuaternionBuilder &);
  flatbuffers::Offset<Quaternion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quaternion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quaternion> CreateQuaternion(
    flatbuffers::FlatBufferBuilder &_fbb,
    double e0 = 0.0,
    double e1 = 0.0,
    double e2 = 0.0,
    double e3 = 0.0) {
  QuaternionBuilder builder_(_fbb);
  builder_.add_e3(e3);
  builder_.add_e2(e2);
  builder_.add_e1(e1);
  builder_.add_e0(e0);
  return builder_.Finish();
}

struct Pose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POS = 4,
    VT_ROT = 6,
    VT_POS_DT = 8,
    VT_ROT_DT = 10,
    VT_POS_DTDT = 12,
    VT_ROT_DTDT = 14
  };
  const SynFlatBuffers::Vector *pos() const {
    return GetPointer<const SynFlatBuffers::Vector *>(VT_POS);
  }
  const SynFlatBuffers::Quaternion *rot() const {
    return GetPointer<const SynFlatBuffers::Quaternion *>(VT_ROT);
  }
  const SynFlatBuffers::Vector *pos_dt() const {
    return GetPointer<const SynFlatBuffers::Vector *>(VT_POS_DT);
  }
  const SynFlatBuffers::Quaternion *rot_dt() const {
    return GetPointer<const SynFlatBuffers::Quaternion *>(VT_ROT_DT);
  }
  const SynFlatBuffers::Vector *pos_dtdt() const {
    return GetPointer<const SynFlatBuffers::Vector *>(VT_POS_DTDT);
  }
  const SynFlatBuffers::Quaternion *rot_dtdt() const {
    return GetPointer<const SynFlatBuffers::Quaternion *>(VT_ROT_DTDT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POS) &&
           verifier.VerifyTable(pos()) &&
           VerifyOffset(verifier, VT_ROT) &&
           verifier.VerifyTable(rot()) &&
           VerifyOffset(verifier, VT_POS_DT) &&
           verifier.VerifyTable(pos_dt()) &&
           VerifyOffset(verifier, VT_ROT_DT) &&
           verifier.VerifyTable(rot_dt()) &&
           VerifyOffset(verifier, VT_POS_DTDT) &&
           verifier.VerifyTable(pos_dtdt()) &&
           VerifyOffset(verifier, VT_ROT_DTDT) &&
           verifier.VerifyTable(rot_dtdt()) &&
           verifier.EndTable();
  }
};

struct PoseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(flatbuffers::Offset<SynFlatBuffers::Vector> pos) {
    fbb_.AddOffset(Pose::VT_POS, pos);
  }
  void add_rot(flatbuffers::Offset<SynFlatBuffers::Quaternion> rot) {
    fbb_.AddOffset(Pose::VT_ROT, rot);
  }
  void add_pos_dt(flatbuffers::Offset<SynFlatBuffers::Vector> pos_dt) {
    fbb_.AddOffset(Pose::VT_POS_DT, pos_dt);
  }
  void add_rot_dt(flatbuffers::Offset<SynFlatBuffers::Quaternion> rot_dt) {
    fbb_.AddOffset(Pose::VT_ROT_DT, rot_dt);
  }
  void add_pos_dtdt(flatbuffers::Offset<SynFlatBuffers::Vector> pos_dtdt) {
    fbb_.AddOffset(Pose::VT_POS_DTDT, pos_dtdt);
  }
  void add_rot_dtdt(flatbuffers::Offset<SynFlatBuffers::Quaternion> rot_dtdt) {
    fbb_.AddOffset(Pose::VT_ROT_DTDT, rot_dtdt);
  }
  explicit PoseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoseBuilder &operator=(const PoseBuilder &);
  flatbuffers::Offset<Pose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pose> CreatePose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SynFlatBuffers::Vector> pos = 0,
    flatbuffers::Offset<SynFlatBuffers::Quaternion> rot = 0,
    flatbuffers::Offset<SynFlatBuffers::Vector> pos_dt = 0,
    flatbuffers::Offset<SynFlatBuffers::Quaternion> rot_dt = 0,
    flatbuffers::Offset<SynFlatBuffers::Vector> pos_dtdt = 0,
    flatbuffers::Offset<SynFlatBuffers::Quaternion> rot_dtdt = 0) {
  PoseBuilder builder_(_fbb);
  builder_.add_rot_dtdt(rot_dtdt);
  builder_.add_pos_dtdt(pos_dtdt);
  builder_.add_rot_dt(rot_dt);
  builder_.add_pos_dt(pos_dt);
  builder_.add_rot(rot);
  builder_.add_pos(pos);
  return builder_.Finish();
}

namespace Approach {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_RANK = 6,
    VT_LANES = 8
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>> *lanes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>> *>(VT_LANES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyOffset(verifier, VT_LANES) &&
           verifier.VerifyVector(lanes()) &&
           verifier.VerifyVectorOfTables(lanes()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(State::VT_RANK, rank, 0);
  }
  void add_lanes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>>> lanes) {
    fbb_.AddOffset(State::VT_LANES, lanes);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    int32_t rank = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>>> lanes = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_lanes(lanes);
  builder_.add_rank(rank);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    int32_t rank = 0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>> *lanes = nullptr) {
  auto lanes__ = lanes ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Approach::Lane>>(*lanes) : 0;
  return SynFlatBuffers::Approach::CreateState(
      _fbb,
      time,
      rank,
      lanes__);
}

struct Lane FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_CONTROLPOINTS = 6
  };
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Vector>> *controlPoints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Vector>> *>(VT_CONTROLPOINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_WIDTH) &&
           VerifyOffset(verifier, VT_CONTROLPOINTS) &&
           verifier.VerifyVector(controlPoints()) &&
           verifier.VerifyVectorOfTables(controlPoints()) &&
           verifier.EndTable();
  }
};

struct LaneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_width(double width) {
    fbb_.AddElement<double>(Lane::VT_WIDTH, width, 0.0);
  }
  void add_controlPoints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Vector>>> controlPoints) {
    fbb_.AddOffset(Lane::VT_CONTROLPOINTS, controlPoints);
  }
  explicit LaneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaneBuilder &operator=(const LaneBuilder &);
  flatbuffers::Offset<Lane> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lane>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lane> CreateLane(
    flatbuffers::FlatBufferBuilder &_fbb,
    double width = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Vector>>> controlPoints = 0) {
  LaneBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_controlPoints(controlPoints);
  return builder_.Finish();
}

inline flatbuffers::Offset<Lane> CreateLaneDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double width = 0.0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Vector>> *controlPoints = nullptr) {
  auto controlPoints__ = controlPoints ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Vector>>(*controlPoints) : 0;
  return SynFlatBuffers::Approach::CreateLane(
      _fbb,
      width,
      controlPoints__);
}

}  // namespace Approach

namespace MAP {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_RANK = 6,
    VT_INTERSECTIONS = 8
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>> *intersections() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>> *>(VT_INTERSECTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyOffset(verifier, VT_INTERSECTIONS) &&
           verifier.VerifyVector(intersections()) &&
           verifier.VerifyVectorOfTables(intersections()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(State::VT_RANK, rank, 0);
  }
  void add_intersections(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>>> intersections) {
    fbb_.AddOffset(State::VT_INTERSECTIONS, intersections);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    int32_t rank = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>>> intersections = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_intersections(intersections);
  builder_.add_rank(rank);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    int32_t rank = 0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>> *intersections = nullptr) {
  auto intersections__ = intersections ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::MAP::intersection>>(*intersections) : 0;
  return SynFlatBuffers::MAP::CreateState(
      _fbb,
      time,
      rank,
      intersections__);
}

struct intersection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPROACHES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::State>> *approaches() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::State>> *>(VT_APPROACHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_APPROACHES) &&
           verifier.VerifyVector(approaches()) &&
           verifier.VerifyVectorOfTables(approaches()) &&
           verifier.EndTable();
  }
};

struct intersectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_approaches(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::State>>> approaches) {
    fbb_.AddOffset(intersection::VT_APPROACHES, approaches);
  }
  explicit intersectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  intersectionBuilder &operator=(const intersectionBuilder &);
  flatbuffers::Offset<intersection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<intersection>(end);
    return o;
  }
};

inline flatbuffers::Offset<intersection> Createintersection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Approach::State>>> approaches = 0) {
  intersectionBuilder builder_(_fbb);
  builder_.add_approaches(approaches);
  return builder_.Finish();
}

inline flatbuffers::Offset<intersection> CreateintersectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Approach::State>> *approaches = nullptr) {
  auto approaches__ = approaches ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Approach::State>>(*approaches) : 0;
  return SynFlatBuffers::MAP::Createintersection(
      _fbb,
      approaches__);
}

}  // namespace MAP

namespace Agent {
namespace WheeledVehicle {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CHASSIS = 6,
    VT_WHEELS = 8
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const SynFlatBuffers::Pose *chassis() const {
    return GetPointer<const SynFlatBuffers::Pose *>(VT_CHASSIS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *wheels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_WHEELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_CHASSIS) &&
           verifier.VerifyTable(chassis()) &&
           VerifyOffset(verifier, VT_WHEELS) &&
           verifier.VerifyVector(wheels()) &&
           verifier.VerifyVectorOfTables(wheels()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_chassis(flatbuffers::Offset<SynFlatBuffers::Pose> chassis) {
    fbb_.AddOffset(State::VT_CHASSIS, chassis);
  }
  void add_wheels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> wheels) {
    fbb_.AddOffset(State::VT_WHEELS, wheels);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> wheels = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_wheels(wheels);
  builder_.add_chassis(chassis);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *wheels = nullptr) {
  auto wheels__ = wheels ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*wheels) : 0;
  return SynFlatBuffers::Agent::WheeledVehicle::CreateState(
      _fbb,
      time,
      chassis,
      wheels__);
}

struct Description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHASSIS_VIS_FILE = 4,
    VT_WHEEL_VIS_FILE = 6,
    VT_TIRE_VIS_FILE = 8,
    VT_NUM_WHEELS = 10
  };
  const flatbuffers::String *chassis_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_CHASSIS_VIS_FILE);
  }
  const flatbuffers::String *wheel_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_WHEEL_VIS_FILE);
  }
  const flatbuffers::String *tire_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_TIRE_VIS_FILE);
  }
  int32_t num_wheels() const {
    return GetField<int32_t>(VT_NUM_WHEELS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHASSIS_VIS_FILE) &&
           verifier.VerifyString(chassis_vis_file()) &&
           VerifyOffset(verifier, VT_WHEEL_VIS_FILE) &&
           verifier.VerifyString(wheel_vis_file()) &&
           VerifyOffset(verifier, VT_TIRE_VIS_FILE) &&
           verifier.VerifyString(tire_vis_file()) &&
           VerifyField<int32_t>(verifier, VT_NUM_WHEELS) &&
           verifier.EndTable();
  }
};

struct DescriptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chassis_vis_file(flatbuffers::Offset<flatbuffers::String> chassis_vis_file) {
    fbb_.AddOffset(Description::VT_CHASSIS_VIS_FILE, chassis_vis_file);
  }
  void add_wheel_vis_file(flatbuffers::Offset<flatbuffers::String> wheel_vis_file) {
    fbb_.AddOffset(Description::VT_WHEEL_VIS_FILE, wheel_vis_file);
  }
  void add_tire_vis_file(flatbuffers::Offset<flatbuffers::String> tire_vis_file) {
    fbb_.AddOffset(Description::VT_TIRE_VIS_FILE, tire_vis_file);
  }
  void add_num_wheels(int32_t num_wheels) {
    fbb_.AddElement<int32_t>(Description::VT_NUM_WHEELS, num_wheels, 0);
  }
  explicit DescriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DescriptionBuilder &operator=(const DescriptionBuilder &);
  flatbuffers::Offset<Description> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Description>(end);
    return o;
  }
};

inline flatbuffers::Offset<Description> CreateDescription(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> chassis_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> wheel_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> tire_vis_file = 0,
    int32_t num_wheels = 0) {
  DescriptionBuilder builder_(_fbb);
  builder_.add_num_wheels(num_wheels);
  builder_.add_tire_vis_file(tire_vis_file);
  builder_.add_wheel_vis_file(wheel_vis_file);
  builder_.add_chassis_vis_file(chassis_vis_file);
  return builder_.Finish();
}

inline flatbuffers::Offset<Description> CreateDescriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *chassis_vis_file = nullptr,
    const char *wheel_vis_file = nullptr,
    const char *tire_vis_file = nullptr,
    int32_t num_wheels = 0) {
  auto chassis_vis_file__ = chassis_vis_file ? _fbb.CreateString(chassis_vis_file) : 0;
  auto wheel_vis_file__ = wheel_vis_file ? _fbb.CreateString(wheel_vis_file) : 0;
  auto tire_vis_file__ = tire_vis_file ? _fbb.CreateString(tire_vis_file) : 0;
  return SynFlatBuffers::Agent::WheeledVehicle::CreateDescription(
      _fbb,
      chassis_vis_file__,
      wheel_vis_file__,
      tire_vis_file__,
      num_wheels);
}

}  // namespace WheeledVehicle

namespace TrackedVehicle {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_CHASSIS = 6,
    VT_TRACK_SHOES = 8,
    VT_SPROCKETS = 10,
    VT_IDLERS = 12,
    VT_ROAD_WHEELS = 14
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const SynFlatBuffers::Pose *chassis() const {
    return GetPointer<const SynFlatBuffers::Pose *>(VT_CHASSIS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *track_shoes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_TRACK_SHOES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *sprockets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_SPROCKETS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *idlers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_IDLERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *road_wheels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *>(VT_ROAD_WHEELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_CHASSIS) &&
           verifier.VerifyTable(chassis()) &&
           VerifyOffset(verifier, VT_TRACK_SHOES) &&
           verifier.VerifyVector(track_shoes()) &&
           verifier.VerifyVectorOfTables(track_shoes()) &&
           VerifyOffset(verifier, VT_SPROCKETS) &&
           verifier.VerifyVector(sprockets()) &&
           verifier.VerifyVectorOfTables(sprockets()) &&
           VerifyOffset(verifier, VT_IDLERS) &&
           verifier.VerifyVector(idlers()) &&
           verifier.VerifyVectorOfTables(idlers()) &&
           VerifyOffset(verifier, VT_ROAD_WHEELS) &&
           verifier.VerifyVector(road_wheels()) &&
           verifier.VerifyVectorOfTables(road_wheels()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_chassis(flatbuffers::Offset<SynFlatBuffers::Pose> chassis) {
    fbb_.AddOffset(State::VT_CHASSIS, chassis);
  }
  void add_track_shoes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> track_shoes) {
    fbb_.AddOffset(State::VT_TRACK_SHOES, track_shoes);
  }
  void add_sprockets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> sprockets) {
    fbb_.AddOffset(State::VT_SPROCKETS, sprockets);
  }
  void add_idlers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> idlers) {
    fbb_.AddOffset(State::VT_IDLERS, idlers);
  }
  void add_road_wheels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> road_wheels) {
    fbb_.AddOffset(State::VT_ROAD_WHEELS, road_wheels);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> track_shoes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> sprockets = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> idlers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Pose>>> road_wheels = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_road_wheels(road_wheels);
  builder_.add_idlers(idlers);
  builder_.add_sprockets(sprockets);
  builder_.add_track_shoes(track_shoes);
  builder_.add_chassis(chassis);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<SynFlatBuffers::Pose> chassis = 0,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *track_shoes = nullptr,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *sprockets = nullptr,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *idlers = nullptr,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Pose>> *road_wheels = nullptr) {
  auto track_shoes__ = track_shoes ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*track_shoes) : 0;
  auto sprockets__ = sprockets ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*sprockets) : 0;
  auto idlers__ = idlers ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*idlers) : 0;
  auto road_wheels__ = road_wheels ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Pose>>(*road_wheels) : 0;
  return SynFlatBuffers::Agent::TrackedVehicle::CreateState(
      _fbb,
      time,
      chassis,
      track_shoes__,
      sprockets__,
      idlers__,
      road_wheels__);
}

struct Description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHASSIS_VIS_FILE = 4,
    VT_TRACK_SHOE_VIS_FILE = 6,
    VT_LEFT_SPROCKET_VIS_FILE = 8,
    VT_RIGHT_SPROCKET_VIS_FILE = 10,
    VT_LEFT_IDLER_VIS_FILE = 12,
    VT_RIGHT_IDLER_VIS_FILE = 14,
    VT_LEFT_ROAD_WHEEL_VIS_FILE = 16,
    VT_RIGHT_ROAD_WHEEL_VIS_FILE = 18,
    VT_NUM_TRACK_SHOES = 20,
    VT_NUM_SPROCKETS = 22,
    VT_NUM_IDLERS = 24,
    VT_NUM_ROAD_WHEELS = 26
  };
  const flatbuffers::String *chassis_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_CHASSIS_VIS_FILE);
  }
  const flatbuffers::String *track_shoe_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_TRACK_SHOE_VIS_FILE);
  }
  const flatbuffers::String *left_sprocket_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_LEFT_SPROCKET_VIS_FILE);
  }
  const flatbuffers::String *right_sprocket_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_RIGHT_SPROCKET_VIS_FILE);
  }
  const flatbuffers::String *left_idler_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_LEFT_IDLER_VIS_FILE);
  }
  const flatbuffers::String *right_idler_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_RIGHT_IDLER_VIS_FILE);
  }
  const flatbuffers::String *left_road_wheel_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_LEFT_ROAD_WHEEL_VIS_FILE);
  }
  const flatbuffers::String *right_road_wheel_vis_file() const {
    return GetPointer<const flatbuffers::String *>(VT_RIGHT_ROAD_WHEEL_VIS_FILE);
  }
  int32_t num_track_shoes() const {
    return GetField<int32_t>(VT_NUM_TRACK_SHOES, 0);
  }
  int32_t num_sprockets() const {
    return GetField<int32_t>(VT_NUM_SPROCKETS, 0);
  }
  int32_t num_idlers() const {
    return GetField<int32_t>(VT_NUM_IDLERS, 0);
  }
  int32_t num_road_wheels() const {
    return GetField<int32_t>(VT_NUM_ROAD_WHEELS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHASSIS_VIS_FILE) &&
           verifier.VerifyString(chassis_vis_file()) &&
           VerifyOffset(verifier, VT_TRACK_SHOE_VIS_FILE) &&
           verifier.VerifyString(track_shoe_vis_file()) &&
           VerifyOffset(verifier, VT_LEFT_SPROCKET_VIS_FILE) &&
           verifier.VerifyString(left_sprocket_vis_file()) &&
           VerifyOffset(verifier, VT_RIGHT_SPROCKET_VIS_FILE) &&
           verifier.VerifyString(right_sprocket_vis_file()) &&
           VerifyOffset(verifier, VT_LEFT_IDLER_VIS_FILE) &&
           verifier.VerifyString(left_idler_vis_file()) &&
           VerifyOffset(verifier, VT_RIGHT_IDLER_VIS_FILE) &&
           verifier.VerifyString(right_idler_vis_file()) &&
           VerifyOffset(verifier, VT_LEFT_ROAD_WHEEL_VIS_FILE) &&
           verifier.VerifyString(left_road_wheel_vis_file()) &&
           VerifyOffset(verifier, VT_RIGHT_ROAD_WHEEL_VIS_FILE) &&
           verifier.VerifyString(right_road_wheel_vis_file()) &&
           VerifyField<int32_t>(verifier, VT_NUM_TRACK_SHOES) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPROCKETS) &&
           VerifyField<int32_t>(verifier, VT_NUM_IDLERS) &&
           VerifyField<int32_t>(verifier, VT_NUM_ROAD_WHEELS) &&
           verifier.EndTable();
  }
};

struct DescriptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chassis_vis_file(flatbuffers::Offset<flatbuffers::String> chassis_vis_file) {
    fbb_.AddOffset(Description::VT_CHASSIS_VIS_FILE, chassis_vis_file);
  }
  void add_track_shoe_vis_file(flatbuffers::Offset<flatbuffers::String> track_shoe_vis_file) {
    fbb_.AddOffset(Description::VT_TRACK_SHOE_VIS_FILE, track_shoe_vis_file);
  }
  void add_left_sprocket_vis_file(flatbuffers::Offset<flatbuffers::String> left_sprocket_vis_file) {
    fbb_.AddOffset(Description::VT_LEFT_SPROCKET_VIS_FILE, left_sprocket_vis_file);
  }
  void add_right_sprocket_vis_file(flatbuffers::Offset<flatbuffers::String> right_sprocket_vis_file) {
    fbb_.AddOffset(Description::VT_RIGHT_SPROCKET_VIS_FILE, right_sprocket_vis_file);
  }
  void add_left_idler_vis_file(flatbuffers::Offset<flatbuffers::String> left_idler_vis_file) {
    fbb_.AddOffset(Description::VT_LEFT_IDLER_VIS_FILE, left_idler_vis_file);
  }
  void add_right_idler_vis_file(flatbuffers::Offset<flatbuffers::String> right_idler_vis_file) {
    fbb_.AddOffset(Description::VT_RIGHT_IDLER_VIS_FILE, right_idler_vis_file);
  }
  void add_left_road_wheel_vis_file(flatbuffers::Offset<flatbuffers::String> left_road_wheel_vis_file) {
    fbb_.AddOffset(Description::VT_LEFT_ROAD_WHEEL_VIS_FILE, left_road_wheel_vis_file);
  }
  void add_right_road_wheel_vis_file(flatbuffers::Offset<flatbuffers::String> right_road_wheel_vis_file) {
    fbb_.AddOffset(Description::VT_RIGHT_ROAD_WHEEL_VIS_FILE, right_road_wheel_vis_file);
  }
  void add_num_track_shoes(int32_t num_track_shoes) {
    fbb_.AddElement<int32_t>(Description::VT_NUM_TRACK_SHOES, num_track_shoes, 0);
  }
  void add_num_sprockets(int32_t num_sprockets) {
    fbb_.AddElement<int32_t>(Description::VT_NUM_SPROCKETS, num_sprockets, 0);
  }
  void add_num_idlers(int32_t num_idlers) {
    fbb_.AddElement<int32_t>(Description::VT_NUM_IDLERS, num_idlers, 0);
  }
  void add_num_road_wheels(int32_t num_road_wheels) {
    fbb_.AddElement<int32_t>(Description::VT_NUM_ROAD_WHEELS, num_road_wheels, 0);
  }
  explicit DescriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DescriptionBuilder &operator=(const DescriptionBuilder &);
  flatbuffers::Offset<Description> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Description>(end);
    return o;
  }
};

inline flatbuffers::Offset<Description> CreateDescription(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> chassis_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> track_shoe_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> left_sprocket_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> right_sprocket_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> left_idler_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> right_idler_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> left_road_wheel_vis_file = 0,
    flatbuffers::Offset<flatbuffers::String> right_road_wheel_vis_file = 0,
    int32_t num_track_shoes = 0,
    int32_t num_sprockets = 0,
    int32_t num_idlers = 0,
    int32_t num_road_wheels = 0) {
  DescriptionBuilder builder_(_fbb);
  builder_.add_num_road_wheels(num_road_wheels);
  builder_.add_num_idlers(num_idlers);
  builder_.add_num_sprockets(num_sprockets);
  builder_.add_num_track_shoes(num_track_shoes);
  builder_.add_right_road_wheel_vis_file(right_road_wheel_vis_file);
  builder_.add_left_road_wheel_vis_file(left_road_wheel_vis_file);
  builder_.add_right_idler_vis_file(right_idler_vis_file);
  builder_.add_left_idler_vis_file(left_idler_vis_file);
  builder_.add_right_sprocket_vis_file(right_sprocket_vis_file);
  builder_.add_left_sprocket_vis_file(left_sprocket_vis_file);
  builder_.add_track_shoe_vis_file(track_shoe_vis_file);
  builder_.add_chassis_vis_file(chassis_vis_file);
  return builder_.Finish();
}

inline flatbuffers::Offset<Description> CreateDescriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *chassis_vis_file = nullptr,
    const char *track_shoe_vis_file = nullptr,
    const char *left_sprocket_vis_file = nullptr,
    const char *right_sprocket_vis_file = nullptr,
    const char *left_idler_vis_file = nullptr,
    const char *right_idler_vis_file = nullptr,
    const char *left_road_wheel_vis_file = nullptr,
    const char *right_road_wheel_vis_file = nullptr,
    int32_t num_track_shoes = 0,
    int32_t num_sprockets = 0,
    int32_t num_idlers = 0,
    int32_t num_road_wheels = 0) {
  auto chassis_vis_file__ = chassis_vis_file ? _fbb.CreateString(chassis_vis_file) : 0;
  auto track_shoe_vis_file__ = track_shoe_vis_file ? _fbb.CreateString(track_shoe_vis_file) : 0;
  auto left_sprocket_vis_file__ = left_sprocket_vis_file ? _fbb.CreateString(left_sprocket_vis_file) : 0;
  auto right_sprocket_vis_file__ = right_sprocket_vis_file ? _fbb.CreateString(right_sprocket_vis_file) : 0;
  auto left_idler_vis_file__ = left_idler_vis_file ? _fbb.CreateString(left_idler_vis_file) : 0;
  auto right_idler_vis_file__ = right_idler_vis_file ? _fbb.CreateString(right_idler_vis_file) : 0;
  auto left_road_wheel_vis_file__ = left_road_wheel_vis_file ? _fbb.CreateString(left_road_wheel_vis_file) : 0;
  auto right_road_wheel_vis_file__ = right_road_wheel_vis_file ? _fbb.CreateString(right_road_wheel_vis_file) : 0;
  return SynFlatBuffers::Agent::TrackedVehicle::CreateDescription(
      _fbb,
      chassis_vis_file__,
      track_shoe_vis_file__,
      left_sprocket_vis_file__,
      right_sprocket_vis_file__,
      left_idler_vis_file__,
      right_idler_vis_file__,
      left_road_wheel_vis_file__,
      right_road_wheel_vis_file__,
      num_track_shoes,
      num_sprockets,
      num_idlers,
      num_road_wheels);
}

}  // namespace TrackedVehicle

namespace Environment {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StateBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DescriptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DescriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DescriptionBuilder &operator=(const DescriptionBuilder &);
  flatbuffers::Offset<Description> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Description>(end);
    return o;
  }
};

inline flatbuffers::Offset<Description> CreateDescription(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DescriptionBuilder builder_(_fbb);
  return builder_.Finish();
}

}  // namespace Environment

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  SynFlatBuffers::Agent::Type message_type() const {
    return static_cast<SynFlatBuffers::Agent::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const SynFlatBuffers::Agent::WheeledVehicle::State *message_as_WheeledVehicle_State() const {
    return message_type() == SynFlatBuffers::Agent::Type_WheeledVehicle_State ? static_cast<const SynFlatBuffers::Agent::WheeledVehicle::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::WheeledVehicle::Description *message_as_WheeledVehicle_Description() const {
    return message_type() == SynFlatBuffers::Agent::Type_WheeledVehicle_Description ? static_cast<const SynFlatBuffers::Agent::WheeledVehicle::Description *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::TrackedVehicle::State *message_as_TrackedVehicle_State() const {
    return message_type() == SynFlatBuffers::Agent::Type_TrackedVehicle_State ? static_cast<const SynFlatBuffers::Agent::TrackedVehicle::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::TrackedVehicle::Description *message_as_TrackedVehicle_Description() const {
    return message_type() == SynFlatBuffers::Agent::Type_TrackedVehicle_Description ? static_cast<const SynFlatBuffers::Agent::TrackedVehicle::Description *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::Environment::State *message_as_Environment_State() const {
    return message_type() == SynFlatBuffers::Agent::Type_Environment_State ? static_cast<const SynFlatBuffers::Agent::Environment::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::Environment::Description *message_as_Environment_Description() const {
    return message_type() == SynFlatBuffers::Agent::Type_Environment_Description ? static_cast<const SynFlatBuffers::Agent::Environment::Description *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Agent::WheeledVehicle::State *State::message_as<SynFlatBuffers::Agent::WheeledVehicle::State>() const {
  return message_as_WheeledVehicle_State();
}

template<> inline const SynFlatBuffers::Agent::WheeledVehicle::Description *State::message_as<SynFlatBuffers::Agent::WheeledVehicle::Description>() const {
  return message_as_WheeledVehicle_Description();
}

template<> inline const SynFlatBuffers::Agent::TrackedVehicle::State *State::message_as<SynFlatBuffers::Agent::TrackedVehicle::State>() const {
  return message_as_TrackedVehicle_State();
}

template<> inline const SynFlatBuffers::Agent::TrackedVehicle::Description *State::message_as<SynFlatBuffers::Agent::TrackedVehicle::Description>() const {
  return message_as_TrackedVehicle_Description();
}

template<> inline const SynFlatBuffers::Agent::Environment::State *State::message_as<SynFlatBuffers::Agent::Environment::State>() const {
  return message_as_Environment_State();
}

template<> inline const SynFlatBuffers::Agent::Environment::Description *State::message_as<SynFlatBuffers::Agent::Environment::Description>() const {
  return message_as_Environment_Description();
}

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(SynFlatBuffers::Agent::Type message_type) {
    fbb_.AddElement<uint8_t>(State::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(State::VT_MESSAGE, message);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Agent::Type message_type = SynFlatBuffers::Agent::Type_NONE,
    flatbuffers::Offset<void> message = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

struct Description FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESCRIPTION_TYPE = 4,
    VT_DESCRIPTION = 6,
    VT_JSON = 8
  };
  SynFlatBuffers::Agent::Type description_type() const {
    return static_cast<SynFlatBuffers::Agent::Type>(GetField<uint8_t>(VT_DESCRIPTION_TYPE, 0));
  }
  const void *description() const {
    return GetPointer<const void *>(VT_DESCRIPTION);
  }
  template<typename T> const T *description_as() const;
  const SynFlatBuffers::Agent::WheeledVehicle::State *description_as_WheeledVehicle_State() const {
    return description_type() == SynFlatBuffers::Agent::Type_WheeledVehicle_State ? static_cast<const SynFlatBuffers::Agent::WheeledVehicle::State *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::WheeledVehicle::Description *description_as_WheeledVehicle_Description() const {
    return description_type() == SynFlatBuffers::Agent::Type_WheeledVehicle_Description ? static_cast<const SynFlatBuffers::Agent::WheeledVehicle::Description *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::TrackedVehicle::State *description_as_TrackedVehicle_State() const {
    return description_type() == SynFlatBuffers::Agent::Type_TrackedVehicle_State ? static_cast<const SynFlatBuffers::Agent::TrackedVehicle::State *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::TrackedVehicle::Description *description_as_TrackedVehicle_Description() const {
    return description_type() == SynFlatBuffers::Agent::Type_TrackedVehicle_Description ? static_cast<const SynFlatBuffers::Agent::TrackedVehicle::Description *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::Environment::State *description_as_Environment_State() const {
    return description_type() == SynFlatBuffers::Agent::Type_Environment_State ? static_cast<const SynFlatBuffers::Agent::Environment::State *>(description()) : nullptr;
  }
  const SynFlatBuffers::Agent::Environment::Description *description_as_Environment_Description() const {
    return description_type() == SynFlatBuffers::Agent::Type_Environment_Description ? static_cast<const SynFlatBuffers::Agent::Environment::Description *>(description()) : nullptr;
  }
  const flatbuffers::String *json() const {
    return GetPointer<const flatbuffers::String *>(VT_JSON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DESCRIPTION_TYPE) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           VerifyType(verifier, description(), description_type()) &&
           VerifyOffset(verifier, VT_JSON) &&
           verifier.VerifyString(json()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Agent::WheeledVehicle::State *Description::description_as<SynFlatBuffers::Agent::WheeledVehicle::State>() const {
  return description_as_WheeledVehicle_State();
}

template<> inline const SynFlatBuffers::Agent::WheeledVehicle::Description *Description::description_as<SynFlatBuffers::Agent::WheeledVehicle::Description>() const {
  return description_as_WheeledVehicle_Description();
}

template<> inline const SynFlatBuffers::Agent::TrackedVehicle::State *Description::description_as<SynFlatBuffers::Agent::TrackedVehicle::State>() const {
  return description_as_TrackedVehicle_State();
}

template<> inline const SynFlatBuffers::Agent::TrackedVehicle::Description *Description::description_as<SynFlatBuffers::Agent::TrackedVehicle::Description>() const {
  return description_as_TrackedVehicle_Description();
}

template<> inline const SynFlatBuffers::Agent::Environment::State *Description::description_as<SynFlatBuffers::Agent::Environment::State>() const {
  return description_as_Environment_State();
}

template<> inline const SynFlatBuffers::Agent::Environment::Description *Description::description_as<SynFlatBuffers::Agent::Environment::Description>() const {
  return description_as_Environment_Description();
}

struct DescriptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_description_type(SynFlatBuffers::Agent::Type description_type) {
    fbb_.AddElement<uint8_t>(Description::VT_DESCRIPTION_TYPE, static_cast<uint8_t>(description_type), 0);
  }
  void add_description(flatbuffers::Offset<void> description) {
    fbb_.AddOffset(Description::VT_DESCRIPTION, description);
  }
  void add_json(flatbuffers::Offset<flatbuffers::String> json) {
    fbb_.AddOffset(Description::VT_JSON, json);
  }
  explicit DescriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DescriptionBuilder &operator=(const DescriptionBuilder &);
  flatbuffers::Offset<Description> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Description>(end);
    return o;
  }
};

inline flatbuffers::Offset<Description> CreateDescription(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Agent::Type description_type = SynFlatBuffers::Agent::Type_NONE,
    flatbuffers::Offset<void> description = 0,
    flatbuffers::Offset<flatbuffers::String> json = 0) {
  DescriptionBuilder builder_(_fbb);
  builder_.add_json(json);
  builder_.add_description(description);
  builder_.add_description_type(description_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Description> CreateDescriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Agent::Type description_type = SynFlatBuffers::Agent::Type_NONE,
    flatbuffers::Offset<void> description = 0,
    const char *json = nullptr) {
  auto json__ = json ? _fbb.CreateString(json) : 0;
  return SynFlatBuffers::Agent::CreateDescription(
      _fbb,
      description_type,
      description,
      json__);
}

}  // namespace Agent

namespace Terrain {
namespace SCM {

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_NODES = 6
  };
  double time() const {
    return GetField<double>(VT_TIME, 0.0);
  }
  const flatbuffers::Vector<const SynFlatBuffers::Terrain::SCM::NodeLevel *> *nodes() const {
    return GetPointer<const flatbuffers::Vector<const SynFlatBuffers::Terrain::SCM::NodeLevel *> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(double time) {
    fbb_.AddElement<double>(State::VT_TIME, time, 0.0);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<const SynFlatBuffers::Terrain::SCM::NodeLevel *>> nodes) {
    fbb_.AddOffset(State::VT_NODES, nodes);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<const SynFlatBuffers::Terrain::SCM::NodeLevel *>> nodes = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double time = 0.0,
    const std::vector<SynFlatBuffers::Terrain::SCM::NodeLevel> *nodes = nullptr) {
  auto nodes__ = nodes ? _fbb.CreateVectorOfStructs<SynFlatBuffers::Terrain::SCM::NodeLevel>(*nodes) : 0;
  return SynFlatBuffers::Terrain::SCM::CreateState(
      _fbb,
      time,
      nodes__);
}

}  // namespace SCM

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  SynFlatBuffers::Terrain::Type message_type() const {
    return static_cast<SynFlatBuffers::Terrain::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const SynFlatBuffers::Terrain::SCM::State *message_as_SCM_State() const {
    return message_type() == SynFlatBuffers::Terrain::Type_SCM_State ? static_cast<const SynFlatBuffers::Terrain::SCM::State *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Terrain::SCM::State *State::message_as<SynFlatBuffers::Terrain::SCM::State>() const {
  return message_as_SCM_State();
}

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(SynFlatBuffers::Terrain::Type message_type) {
    fbb_.AddElement<uint8_t>(State::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(State::VT_MESSAGE, message);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Terrain::Type message_type = SynFlatBuffers::Terrain::Type_NONE,
    flatbuffers::Offset<void> message = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

}  // namespace Terrain

namespace Sensor {

struct SensorBuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_BUFFER = 8
  };
  int32_t Width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t Height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  const flatbuffers::Vector<uint8_t> *Buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(Buffer()) &&
           verifier.EndTable();
  }
};

struct SensorBufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Width(int32_t Width) {
    fbb_.AddElement<int32_t>(SensorBuffer::VT_WIDTH, Width, 0);
  }
  void add_Height(int32_t Height) {
    fbb_.AddElement<int32_t>(SensorBuffer::VT_HEIGHT, Height, 0);
  }
  void add_Buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Buffer) {
    fbb_.AddOffset(SensorBuffer::VT_BUFFER, Buffer);
  }
  explicit SensorBufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SensorBufferBuilder &operator=(const SensorBufferBuilder &);
  flatbuffers::Offset<SensorBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SensorBuffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<SensorBuffer> CreateSensorBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Width = 0,
    int32_t Height = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Buffer = 0) {
  SensorBufferBuilder builder_(_fbb);
  builder_.add_Buffer(Buffer);
  builder_.add_Height(Height);
  builder_.add_Width(Width);
  return builder_.Finish();
}

inline flatbuffers::Offset<SensorBuffer> CreateSensorBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Width = 0,
    int32_t Height = 0,
    const std::vector<uint8_t> *Buffer = nullptr) {
  auto Buffer__ = Buffer ? _fbb.CreateVector<uint8_t>(*Buffer) : 0;
  return SynFlatBuffers::Sensor::CreateSensorBuffer(
      _fbb,
      Width,
      Height,
      Buffer__);
}

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4,
    VT_TYPE = 6
  };
  const SynFlatBuffers::Sensor::SensorBuffer *buffer() const {
    return GetPointer<const SynFlatBuffers::Sensor::SensorBuffer *>(VT_BUFFER);
  }
  SynFlatBuffers::Sensor::Type type() const {
    return static_cast<SynFlatBuffers::Sensor::Type>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyTable(buffer()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<SynFlatBuffers::Sensor::SensorBuffer> buffer) {
    fbb_.AddOffset(State::VT_BUFFER, buffer);
  }
  void add_type(SynFlatBuffers::Sensor::Type type) {
    fbb_.AddElement<int8_t>(State::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<SynFlatBuffers::Sensor::SensorBuffer> buffer = 0,
    SynFlatBuffers::Sensor::Type type = SynFlatBuffers::Sensor::Type_Camera_RGBA8) {
  StateBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_type(type);
  return builder_.Finish();
}

}  // namespace Sensor

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>> *buffer() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.VerifyVectorOfTables(buffer()) &&
           verifier.EndTable();
  }
};

struct BufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>>> buffer) {
    fbb_.AddOffset(Buffer::VT_BUFFER, buffer);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferBuilder &operator=(const BufferBuilder &);
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SynFlatBuffers::Message>>> buffer = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SynFlatBuffers::Message>> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<flatbuffers::Offset<SynFlatBuffers::Message>>(*buffer) : 0;
  return SynFlatBuffers::CreateBuffer(
      _fbb,
      buffer__);
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6,
    VT_RANK = 8
  };
  SynFlatBuffers::Type message_type() const {
    return static_cast<SynFlatBuffers::Type>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const SynFlatBuffers::Agent::State *message_as_Agent_State() const {
    return message_type() == SynFlatBuffers::Type_Agent_State ? static_cast<const SynFlatBuffers::Agent::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Agent::Description *message_as_Agent_Description() const {
    return message_type() == SynFlatBuffers::Type_Agent_Description ? static_cast<const SynFlatBuffers::Agent::Description *>(message()) : nullptr;
  }
  const SynFlatBuffers::SPAT::State *message_as_SPAT_State() const {
    return message_type() == SynFlatBuffers::Type_SPAT_State ? static_cast<const SynFlatBuffers::SPAT::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::MAP::State *message_as_MAP_State() const {
    return message_type() == SynFlatBuffers::Type_MAP_State ? static_cast<const SynFlatBuffers::MAP::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Terrain::State *message_as_Terrain_State() const {
    return message_type() == SynFlatBuffers::Type_Terrain_State ? static_cast<const SynFlatBuffers::Terrain::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Sensor::State *message_as_Sensor_State() const {
    return message_type() == SynFlatBuffers::Type_Sensor_State ? static_cast<const SynFlatBuffers::Sensor::State *>(message()) : nullptr;
  }
  const SynFlatBuffers::Approach::State *message_as_Approach_State() const {
    return message_type() == SynFlatBuffers::Type_Approach_State ? static_cast<const SynFlatBuffers::Approach::State *>(message()) : nullptr;
  }
  uint32_t rank() const {
    return GetField<uint32_t>(VT_RANK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyType(verifier, message(), message_type()) &&
           VerifyField<uint32_t>(verifier, VT_RANK) &&
           verifier.EndTable();
  }
};

template<> inline const SynFlatBuffers::Agent::State *Message::message_as<SynFlatBuffers::Agent::State>() const {
  return message_as_Agent_State();
}

template<> inline const SynFlatBuffers::Agent::Description *Message::message_as<SynFlatBuffers::Agent::Description>() const {
  return message_as_Agent_Description();
}

template<> inline const SynFlatBuffers::SPAT::State *Message::message_as<SynFlatBuffers::SPAT::State>() const {
  return message_as_SPAT_State();
}

template<> inline const SynFlatBuffers::MAP::State *Message::message_as<SynFlatBuffers::MAP::State>() const {
  return message_as_MAP_State();
}

template<> inline const SynFlatBuffers::Terrain::State *Message::message_as<SynFlatBuffers::Terrain::State>() const {
  return message_as_Terrain_State();
}

template<> inline const SynFlatBuffers::Sensor::State *Message::message_as<SynFlatBuffers::Sensor::State>() const {
  return message_as_Sensor_State();
}

template<> inline const SynFlatBuffers::Approach::State *Message::message_as<SynFlatBuffers::Approach::State>() const {
  return message_as_Approach_State();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(SynFlatBuffers::Type message_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Message::VT_MESSAGE, message);
  }
  void add_rank(uint32_t rank) {
    fbb_.AddElement<uint32_t>(Message::VT_RANK, rank, 0);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    SynFlatBuffers::Type message_type = SynFlatBuffers::Type_NONE,
    flatbuffers::Offset<void> message = 0,
    uint32_t rank = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

namespace SPAT {

}  // namespace SPAT

namespace Approach {

}  // namespace Approach

namespace MAP {

}  // namespace MAP

namespace Agent {
namespace WheeledVehicle {

}  // namespace WheeledVehicle

namespace TrackedVehicle {

}  // namespace TrackedVehicle

namespace Environment {

}  // namespace Environment

}  // namespace Agent

namespace Terrain {
namespace SCM {

}  // namespace SCM

}  // namespace Terrain

namespace Sensor {

}  // namespace Sensor

namespace Agent {

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_WheeledVehicle_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::WheeledVehicle::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_WheeledVehicle_Description: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::WheeledVehicle::Description *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_TrackedVehicle_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::TrackedVehicle::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_TrackedVehicle_Description: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::TrackedVehicle::Description *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Environment_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::Environment::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Environment_Description: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::Environment::Description *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Agent

namespace Terrain {

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_SCM_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Terrain::SCM::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace Terrain

inline bool VerifyType(flatbuffers::Verifier &verifier, const void *obj, Type type) {
  switch (type) {
    case Type_NONE: {
      return true;
    }
    case Type_Agent_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Agent_Description: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Agent::Description *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_SPAT_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::SPAT::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_MAP_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::MAP::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Terrain_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Terrain::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Sensor_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Sensor::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Type_Approach_State: {
      auto ptr = reinterpret_cast<const SynFlatBuffers::Approach::State *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyType(
        verifier,  values->Get(i), types->GetEnum<Type>(i))) {
      return false;
    }
  }
  return true;
}

inline const SynFlatBuffers::Buffer *GetBuffer(const void *buf) {
  return flatbuffers::GetRoot<SynFlatBuffers::Buffer>(buf);
}

inline const SynFlatBuffers::Buffer *GetSizePrefixedBuffer(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<SynFlatBuffers::Buffer>(buf);
}

inline bool VerifyBufferBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SynFlatBuffers::Buffer>(nullptr);
}

inline bool VerifySizePrefixedBufferBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SynFlatBuffers::Buffer>(nullptr);
}

inline void FinishBufferBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SynFlatBuffers::Buffer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBufferBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<SynFlatBuffers::Buffer> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace SynFlatBuffers

#endif  // FLATBUFFERS_GENERATED_SYNFLATBUFFERS_SYNFLATBUFFERS_H_
